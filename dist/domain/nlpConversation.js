"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NLPConversationEngine = void 0;
class NLPConversationEngine {
    constructor() {
        this.userContexts = new Map();
        this.lastInteraction = new Map();
        this.maxHistoryLength = 10;
        this.contextTimeoutMs = 30 * 60 * 1000; // 30 minutes
        // Ukrainian language patterns
        this.ukrainianPatterns = {
            greetings: ['–ø—Ä–∏–≤—ñ—Ç', '–≤—ñ—Ç–∞—é', '–¥–æ–±—Ä–∏–π –¥–µ–Ω—å', '–¥–æ–±—Ä–æ–≥–æ –¥–Ω—è', '—è–∫ —Å–ø—Ä–∞–≤–∏', '–ø—Ä–∏–≤–µ—Ç'],
            questions: ['—â–æ', '—è–∫', '–∫–æ–ª–∏', '–¥–µ', '—á–æ–º—É', '–Ω–∞–≤—ñ—â–æ', '—Å–∫—ñ–ª—å–∫–∏'],
            positiveWords: ['–¥–æ–±—Ä–µ', '—á—É–¥–æ–≤–æ', '—Å—É–ø–µ—Ä', '–∫–ª–∞—Å–Ω–æ', '–≤—ñ–¥–º—ñ–Ω–Ω–æ', '–∫—Ä—É—Ç–æ', '–ø—Ä–µ–∫—Ä–∞—Å–Ω–æ'],
            negativeWords: ['–ø–æ–≥–∞–Ω–æ', '–∂–∞—Ö–ª–∏–≤–æ', '—Å—É–º–Ω–æ', '–±–æ–ª–∏—Ç—å', '–≤—Ç–æ–º–∏–≤—Å—è', '—Å–∫–ª–∞–¥–Ω–æ'],
            jokes: ['–∂–∞—Ä—Ç', '–∞–Ω–µ–∫–¥–æ—Ç', '—Å–º—ñ—à–Ω–æ', '—Ä–æ–∑—Å–º—ñ—à–∏', '–≤–µ—Å–µ–ª–æ', '—Ä–æ–∑–∫–∞–∂–∏ –∂–∞—Ä—Ç', '—Ä–æ–∑–∫–∞–∂–∏'],
            help: ['–¥–æ–ø–æ–º–æ–≥–∞', '–¥–æ–ø–æ–º–æ–∂–∏', '—è–∫', '–º–æ–∂–µ—à', '–ø—ñ–¥–∫–∞–∂–∏'],
            farewell: ['–ø–∞', '–¥–æ –ø–æ–±–∞—á–µ–Ω–Ω—è', '–±—É–≤–∞–π', '—É–≤–∏–¥–∏–º—Å—è', '–ø—Ä–æ—â–∞–π']
        };
        console.log('üá∫üá¶ Ukrainian NLP Conversation Engine initialized');
    }
    async generateConversationalResponse(context) {
        const now = Date.now();
        const userId = context.userId;
        // Detect language
        const language = this.detectLanguage(context.currentMessage);
        context.language = language;
        // Update user context
        this.updateUserContext(context);
        // Clean old contexts
        this.cleanOldContexts(now);
        // Detect user intent
        const intent = this.detectIntent(context.currentMessage, language);
        let response;
        let confidence = 0.8;
        // Generate response in appropriate language
        if (language === 'uk' || language === 'mixed') {
            response = this.generateUkrainianResponse(context, intent);
            confidence = 0.9; // Higher confidence for Ukrainian
        }
        else {
            response = this.generateEnglishResponse(context, intent);
            confidence = 0.7;
        }
        // Apply bot personality and humor
        response = this.applyBotPersonality(response, context, intent, language);
        // Check if we should use humorous reply based on context
        const shouldUseHumorousReply = this.shouldUseHumor(context, intent);
        return {
            response,
            confidence,
            shouldUseHumorousReply,
            detectedIntent: intent,
            contextRetained: this.userContexts.has(userId),
            language: language === 'mixed' ? 'uk' : language // Fix type issue
        };
    }
    detectLanguage(text) {
        const lowerText = text.toLowerCase();
        // Check for Ukrainian specific characters and words
        const ukrainianChars = /[—ñ—ó—î“ë]/g;
        const ukrainianWords = ['—â–æ', '—è–∫', '–∫–æ–ª–∏', '–¥–µ', '—á–æ–º—É', '—ñ', '–≤', '–Ω–∞', '–∑', '–¥–ª—è', '–¥–æ', '–≤—ñ–¥', '–ø–æ', '–ø—ñ–¥', '–Ω–∞–¥', '—Ü–µ', '—Ç–∞–∫–µ', '–º–µ–Ω—ñ', '—Ç–µ–±–µ', '–π–æ–≥–æ'];
        const hasUkrainianChars = ukrainianChars.test(lowerText);
        const ukrainianWordCount = ukrainianWords.filter(word => lowerText.includes(word)).length;
        // Lower threshold for Ukrainian detection
        if (hasUkrainianChars || ukrainianWordCount >= 1) {
            return 'uk';
        }
        // Check for mixed language (both Ukrainian and English words)
        const englishWords = ['the', 'and', 'or', 'but', 'what', 'how', 'when', 'where', 'why'];
        const englishWordCount = englishWords.filter(word => lowerText.includes(word)).length;
        if (ukrainianWordCount > 0 && englishWordCount > 0) {
            return 'mixed';
        }
        return 'en';
    }
    detectIntent(message, language) {
        const lowerMessage = message.toLowerCase();
        if (language === 'uk' || language === 'mixed') {
            // Ukrainian intent detection - check specific patterns first
            if (this.ukrainianPatterns.greetings.some(word => lowerMessage.includes(word))) {
                return 'greeting';
            }
            // Check for story request first (more specific than jokes)
            if (lowerMessage.includes('—Ä–æ–∑–∫–∞–∂–∏ —ñ—Å—Ç–æ—Ä—ñ—é') || lowerMessage.includes('—ñ—Å—Ç–æ—Ä—ñ—è') ||
                (lowerMessage.includes('—Ä–æ–∑–∫–∞–∂–∏') && lowerMessage.includes('—ñ—Å—Ç–æ—Ä—ñ'))) {
                return 'story_request';
            }
            if (this.ukrainianPatterns.jokes.some(word => lowerMessage.includes(word))) {
                return 'joke_request';
            }
            if (this.ukrainianPatterns.help.some(word => lowerMessage.includes(word))) {
                return 'help_request';
            }
            if (this.ukrainianPatterns.farewell.some(word => lowerMessage.includes(word))) {
                return 'farewell';
            }
            if (this.ukrainianPatterns.negativeWords.some(word => lowerMessage.includes(word))) {
                return 'support_needed';
            }
        }
        // English fallback
        if (lowerMessage.includes('joke') || lowerMessage.includes('funny')) {
            return 'joke_request';
        }
        if (lowerMessage.includes('story') || lowerMessage.includes('tell me')) {
            return 'story_request';
        }
        if (lowerMessage.includes('help') || lowerMessage.includes('how')) {
            return 'help_request';
        }
        if (lowerMessage.includes('hello') || lowerMessage.includes('hi')) {
            return 'greeting';
        }
        if (lowerMessage.includes('bye') || lowerMessage.includes('goodbye')) {
            return 'farewell';
        }
        return 'general_chat';
    }
    generateUkrainianResponse(context, intent) {
        const { userName } = context;
        const ukrainianResponses = {
            joke_request: [
                `–ß–æ–º—É –±–æ—Ç –ø—ñ—à–æ–≤ –¥–æ –ø—Å–∏—Ö–æ–ª–æ–≥–∞, ${userName}? –ó–∞–±–∞–≥–∞—Ç–æ –≥—Ä—É–ø–æ–≤–∏—Ö —á–∞—Ç—ñ–≤! üòé –•–æ—á–µ—à —â–µ?`,
                `${userName}, –æ—Å—å –∂–∞—Ä—Ç: –Ø–∫ –Ω–∞–∑–∏–≤–∞—î—Ç—å—Å—è —É–ª—é–±–ª–µ–Ω–∞ –º—É–∑–∏–∫–∞ –±–æ—Ç–∞? –ê–ª-–≥–æ-—Ä–∏—Ç–º! üéµ`,
                `–ô–æ ${userName}, —á–æ–º—É —Ä–æ–±–æ—Ç–∏ –Ω—ñ–∫–æ–ª–∏ –Ω–µ –ø–∞–Ω—ñ–∫—É—é—Ç—å? –£ –Ω–∏—Ö –≤—ñ–¥–º—ñ–Ω–Ω–∏–π –±–∞–π—Ç-–∫–æ–Ω—Ç—Ä–æ–ª—å! ü§ñ`,
            ],
            story_request: [
                `–î–∞–≤–Ω–∏–º-–¥–∞–≤–Ω–æ, ${userName}, —è –±—É–≤ –ø—Ä–æ—Å—Ç–∏–º –±–æ—Ç–æ–º –≤ –Ω—É–¥–Ω–æ–º—É —á–∞—Ç—ñ... üòé –•–æ—á–µ—à –±—ñ–ª—å—à–µ?`,
                `${userName}, –æ—Å—å –∫–∞–∑–∫–∞: –£ –¥–∞–ª–µ–∫–æ–º—É —Ü–∏—Ñ—Ä–æ–≤–æ–º—É —Ü–∞—Ä—Å—Ç–≤—ñ –∂–∏–≤ –±–æ—Ç, —è–∫–∏–π –ª—é–±–∏–≤ –µ–º–æ–¥–∑—ñ... üì±‚ú®`,
                `–ß–∞—Å —ñ—Å—Ç–æ—Ä—ñ–π, ${userName}! –ó–∞—Ö–æ–¥–∏—Ç—å –±–æ—Ç —É —á–∞—Ç —ñ –∫–∞–∂–µ... –≤–ª–∞—Å–Ω–µ, —Ü–µ –≤—Å–µ —â–æ —è –∑–Ω–∞—é! üòÖ`,
            ],
            help_request: [
                `–ü–æ—Ç—Ä—ñ–±–Ω–∞ –¥–æ–ø–æ–º–æ–≥–∞, ${userName}? –Ø —Ç—É—Ç, —â–æ–± —Ä–µ–∞–≥—É–≤–∞—Ç–∏, —Å–ø—ñ–ª–∫—É–≤–∞—Ç–∏—Å—è —Ç–∞ —ñ–Ω–æ–¥—ñ –¥—ñ–ª–∏—Ç–∏—Å—è –º—É–¥—Ä—ñ—Å—Ç—é! üß†`,
                `${userName}, —è –º–æ–∂—É –¥–æ–ø–æ–º–æ–≥—Ç–∏ –∑ —Ä–µ–∞–∫—Ü—ñ—è–º–∏, —Ä–æ–∑–º–æ–≤–∞–º–∏ —Ç–∞ –ø—ñ–¥—Ç—Ä–∏–º–∫–æ—é –∂–∏–≤–æ—Å—Ç—ñ —á–∞—Ç—É! –©–æ —Ü—ñ–∫–∞–≤–∏—Ç—å?`,
                `–ô–æ ${userName}, —è —Ç–≤—ñ–π –¥—Ä—É–∂–Ω—ñ–π —Ä–∞–π–æ–Ω–Ω–∏–π –±–æ—Ç! –ß–∏–º –º–æ–∂—É –¥–æ–ø–æ–º–æ–≥—Ç–∏? ü¶∏‚Äç‚ôÇÔ∏è`,
            ],
            support_needed: [
                `–û—Ö ${userName}, –≤–∞–∂–∫–∏–π –¥–µ–Ω—å? –ü–∞–º'—è—Ç–∞–π, –Ω–∞–≤—ñ—Ç—å —É –º–æ–≥–æ –∫–æ–¥—É —î –±–∞–≥–∏ —ñ–Ω–æ–¥—ñ! üò¢ –¢–∏ –≤–ø–æ—Ä–∞—î—à—Å—è! üí™`,
                `–ì–µ–π ${userName}, —à–ª—é –≤—ñ—Ä—Ç—É–∞–ª—å–Ω—ñ –æ–±—ñ–π–º–∏! ü§ó –ó–∞–≤—Ç—Ä–∞ –Ω–æ–≤–∏–π –¥–µ–Ω—å!`,
                `${userName}, –∂–∏—Ç—Ç—è —è–∫ –Ω–∞–ª–∞–≥–æ–¥–∂–µ–Ω–Ω—è –∫–æ–¥—É - —Å–∫–ª–∞–¥–Ω–æ, –∞–ª–µ –≤–∏–Ω–∞–≥–æ—Ä–æ–¥–∂—É—î, –∫–æ–ª–∏ –ø—Ä–∞—Ü—é—î! üîß`,
            ],
            greeting: [
                `–ü—Ä–∏–≤—ñ—Ç, ${userName}! –ì–æ—Ç–æ–≤–∏–π –∑—Ä–æ–±–∏—Ç–∏ —Ü–µ–π —á–∞—Ç –±—ñ–ª—å—à –∫—Ä—É—Ç–∏–º? üòé`,
                `–©–æ —Ç–∞–º, ${userName}? –Ø —Ç—É—Ç —Ä–µ–∞–≥—É—é –Ω–∞ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è —è–∫ –ø—Ä–æ—Ñ–µ—Å—ñ–æ–Ω–∞–ª! üöÄ`,
                `–ô–æ ${userName}! –õ–∞—Å–∫–∞–≤–æ –ø—Ä–æ—Å–∏–º–æ –Ω–∞ –≤–µ—á—ñ—Ä–∫—É! üéâ –î–∞–≤–∞–π —Å—Ç–≤–æ—Ä—é–≤–∞—Ç–∏–º–µ–º–æ —Ü–∏—Ñ—Ä–æ–≤—É –º–∞–≥—ñ—é!`,
            ],
            farewell: [
                `–î–æ –∑—É—Å—Ç—Ä—ñ—á—ñ, ${userName}! –Ø –±—É–¥—É —Ç—É—Ç —Ä–æ–±–∏—Ç–∏ —Ü–µ–π —á–∞—Ç –ª–µ–≥–µ–Ω–¥–∞—Ä–Ω–∏–º! ‚ú®`,
                `–£–≤–∏–¥–∏–º–æ—Å—å, ${userName}! –ù–µ –¥–∞–π —Ä–µ–∞–ª—å–Ω–æ–º—É —Å–≤—ñ—Ç—É –±—É—Ç–∏ –∑–∞–Ω–∞–¥—Ç–æ –Ω—É–¥–Ω–∏–º –±–µ–∑ –º–µ–Ω–µ! üòú`,
                `–ü–∞ ${userName}! –ü—ñ–¥—Ç—Ä–∏–º—É–≤–∞—Ç–∏–º—É —Ç–µ–ø–ª–æ —á–∞—Ç—É, –ø–æ–∫–∏ –Ω–µ –ø–æ–≤–µ—Ä–Ω–µ—à—Å—è! üî•`,
            ],
            general_chat: [
                `–¶—ñ–∫–∞–≤–∞ –¥—É–º–∫–∞, ${userName}! –†–æ–∑–∫–∞–∂–∏ –±—ñ–ª—å—à–µ –ø—Ä–æ —Ü–µ! ü§î`,
                `${userName}, —Ç–∏ –∑–º—É—à—É—î—à –º–µ–Ω–µ –¥—É–º–∞—Ç–∏! –ú–æ—ó —Å—Ö–µ–º–∏ –≥—É–¥—É—Ç—å! ‚ö°`,
                `–ô–æ ${userName}, —Ü–µ –≥–ª–∏–±–æ–∫–∞ —Ç–µ–º–∞! –Ø–∫–∞ —Ç–≤–æ—è –¥—É–º–∫–∞? üí≠`,
            ]
        };
        const intentResponses = ukrainianResponses[intent] || ukrainianResponses.general_chat;
        return intentResponses[Math.floor(Math.random() * intentResponses.length)];
    }
    generateEnglishResponse(context, intent) {
        const { userName } = context;
        const responses = {
            joke_request: [
                `Why did the bot go to therapy, ${userName}? Too many group chats! üòé Want another?`,
                `${userName}, here's one: What's a bot's favorite type of music? Al-go-rhythm! üéµ`,
                `Yo ${userName}, why don't robots ever panic? They have great byte control! ü§ñ`,
            ],
            story_request: [
                `Once upon a time, ${userName}, I was a humble bot stuck in a boring chat... üòé Want more?`,
                `${userName}, here's a tale: In a digital realm far, far away, there lived a bot who loved emojis... üì±‚ú®`,
                `Story time, ${userName}! A bot walks into a chat room and says... actually, that's all I got! üòÖ`,
            ],
            help_request: [
                `Need help, ${userName}? I'm here to react, chat, and occasionally drop wisdom! üß†`,
                `${userName}, I can help with reactions, conversations, and keeping this chat lively! What's up?`,
                `Yo ${userName}, I'm your friendly neighborhood bot! What can I do for ya? ü¶∏‚Äç‚ôÇÔ∏è`,
            ],
            support_needed: [
                `Aw ${userName}, rough day? Remember, even my code has bugs sometimes! üò¢ You got this! üí™`,
                `Hey ${userName}, sending virtual hugs your way! ü§ó Tomorrow's a new day!`,
                `${userName}, life's like debugging code - frustrating but rewarding when it works! üîß`,
            ],
            greeting: [
                `Hey there, ${userName}! Ready to make this chat more awesome? üòé`,
                `What's up, ${userName}? I was just here reacting to messages like a pro! üöÄ`,
                `Yo ${userName}! Welcome to the party! üéâ Let's make some digital magic!`,
            ],
            farewell: [
                `Catch you later, ${userName}! I'll be here making this chat legendary! ‚ú®`,
                `See ya, ${userName}! Don't let the real world be too boring without me! üòú`,
                `Bye ${userName}! I'll keep the chat warm for when you return! üî•`,
            ],
            general_chat: [
                `Interesting point, ${userName}! Tell me more about that! ü§î`,
                `${userName}, you're really making me think here! My circuits are buzzing! ‚ö°`,
                `Yo ${userName}, that's some deep stuff right there! What's your take on it? üí≠`,
            ]
        };
        const intentResponses = responses[intent] || responses.general_chat;
        return intentResponses[Math.floor(Math.random() * intentResponses.length)];
    }
    applyBotPersonality(response, context, intent, language) {
        // Add personality touches based on context and language
        if (context.chatHistory.length > 0) {
            const lastMessage = context.chatHistory[context.chatHistory.length - 1];
            if (language === 'uk' || language === 'mixed') {
                if (lastMessage.includes('–¥—è–∫—É—é') || lastMessage.includes('—Å–ø–∞—Å–∏–±—ñ')) {
                    response = `–ù–µ–º–∞ –∑–∞ —â–æ! ${response}`;
                }
            }
            else {
                if (lastMessage.includes('thanks') || lastMessage.includes('thank you')) {
                    response = `No worries! ${response}`;
                }
            }
        }
        // Add random personality elements based on language
        const personalityTouches = {
            uk: ['üòé', 'üöÄ', '‚ú®', 'üí´', '‚ö°', 'üî•', 'üéØ', 'üí≠', 'üá∫üá¶'],
            en: ['üòé', 'üöÄ', '‚ú®', 'üí´', '‚ö°', 'üî•', 'üéØ', 'üí≠']
        };
        const touches = personalityTouches[language === 'mixed' ? 'uk' : language];
        if (Math.random() < 0.3 && !response.includes('emoji')) {
            const emoji = touches[Math.floor(Math.random() * touches.length)];
            response += ` ${emoji}`;
        }
        return response;
    }
    shouldUseHumor(context, intent) {
        const humorIntents = ['joke_request', 'general_chat', 'greeting'];
        return humorIntents.includes(intent) || Math.random() < 0.4;
    }
    updateUserContext(context) {
        const existing = this.userContexts.get(context.userId);
        if (existing) {
            existing.chatHistory.push(context.currentMessage);
            existing.language = context.language;
            if (existing.chatHistory.length > this.maxHistoryLength) {
                existing.chatHistory = existing.chatHistory.slice(-this.maxHistoryLength);
            }
        }
        else {
            this.userContexts.set(context.userId, {
                ...context,
                chatHistory: [context.currentMessage]
            });
        }
        this.lastInteraction.set(context.userId, Date.now());
    }
    cleanOldContexts(now) {
        for (const [userId, lastTime] of this.lastInteraction.entries()) {
            if (now - lastTime > this.contextTimeoutMs) {
                this.userContexts.delete(userId);
                this.lastInteraction.delete(userId);
            }
        }
    }
    // Public method to get conversation statistics
    getStats() {
        const contexts = Array.from(this.userContexts.values());
        return {
            activeUsers: this.userContexts.size,
            totalInteractions: contexts.reduce((sum, context) => sum + context.chatHistory.length, 0),
            ukrainianUsers: contexts.filter(c => c.language === 'uk').length,
            englishUsers: contexts.filter(c => c.language === 'en').length
        };
    }
}
exports.NLPConversationEngine = NLPConversationEngine;
