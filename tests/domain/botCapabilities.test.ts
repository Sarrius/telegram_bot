import { BotCapabilities, BotCapability } from '../../src/domain/botCapabilities';
import { CapabilityFuzzyMatcher } from '../../src/config/vocabulary/capabilityFuzzyMatcher';

// –ú–æ–∫–∞—î–º–æ CapabilityFuzzyMatcher
jest.mock('../../src/config/vocabulary/capabilityFuzzyMatcher');

describe('BotCapabilities', () => {
  let botCapabilities: BotCapabilities;

  beforeEach(() => {
    botCapabilities = new BotCapabilities();
  });

  describe('detectCapabilityRequest', () => {
    let mockFuzzyMatcher: jest.Mocked<CapabilityFuzzyMatcher>;

    beforeEach(() => {
      mockFuzzyMatcher = {
        detectCapabilityRequest: jest.fn()
      } as any;
      
      // @ts-ignore - –¥–æ—Å—Ç—É–ø –¥–æ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –ø–æ–ª—è –¥–ª—è —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è
      botCapabilities.fuzzyMatcher = mockFuzzyMatcher;
    });

    it('should detect Ukrainian capability requests with fuzzy matching', () => {
      const ukrainianRequests = [
        '—â–æ —Ç–∏ –º–æ–∂–µ—à',
        '—â–æ –º–æ–∂–µ—à —Ä–æ–±–∏—Ç–∏',
        '–º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ',
        '—Ñ—É–Ω–∫—Ü—ñ—ó',
        '–∫–æ–º–∞–Ω–¥–∏',
        '—â–æ –≤–º—ñ—î—à',
        '—è–∫—ñ —Ñ—É–Ω–∫—Ü—ñ—ó',
        '—â–æ —Ä–æ–±–∏—à',
        '—Ç–≤–æ—ó –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ',
        '—Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥',
        '–¥–æ–ø–æ–º–æ–≥–∞',
        '—â–æ —Ç–∏ –≤–º—ñ—î—à —Ä–æ–±–∏—Ç–∏',
        '—Ä–æ–∑–∫–∞–∂–∏ –ø—Ä–æ —Å–µ–±–µ',
        '—â–æ —Ç–∏ —É–º—ñ—î—à',
        '–ø–æ–∫–∞–∂–∏ –∫–æ–º–∞–Ω–¥–∏'
      ];

      ukrainianRequests.forEach(request => {
        mockFuzzyMatcher.detectCapabilityRequest.mockReturnValueOnce({
          isCapabilityRequest: true,
          confidence: 1.0,
          language: 'uk',
          matchedTrigger: request
        });

        const result = botCapabilities.detectCapabilityRequest(request);
        expect(result.isRequest).toBe(true);
        expect(result.language).toBe('uk');
        expect(result.confidence).toBe(1.0);
      });
    });

    it('should detect Ukrainian capability requests with typos', () => {
      const requestsWithTypos = [
        { text: '—à–æ —Ç–∏ –º–æ–∂–µ—à', original: '—â–æ —Ç–∏ –º–æ–∂–µ—à' },
        { text: '–º–æ–∂–ª–∏–≤–æ—Å—Ü—ñ', original: '–º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ' },
        { text: '—Ñ—É–∫–Ω—Ü—ñ—ó', original: '—Ñ—É–Ω–∫—Ü—ñ—ó' },
        { text: '–∫–æ–º–º–∞–Ω–¥—ã', original: '–∫–æ–º–∞–Ω–¥–∏' }
      ];

      requestsWithTypos.forEach(({ text, original }) => {
        mockFuzzyMatcher.detectCapabilityRequest.mockReturnValueOnce({
          isCapabilityRequest: true,
          confidence: 0.85,
          language: 'uk',
          matchedTrigger: original
        });

        const result = botCapabilities.detectCapabilityRequest(text);
        expect(result.isRequest).toBe(true);
        expect(result.language).toBe('uk');
        expect(result.confidence).toBe(0.85);
        expect(result.matchedTrigger).toBe(original);
      });
    });

    it('should detect English capability requests with fuzzy matching', () => {
      const englishRequests = [
        'what can you do',
        'capabilities',
        'features',
        'commands',
        'help',
        'what do you do',
        'your features',
        'bot capabilities',
        'list commands',
        'show features',
        'what are your functions',
        'bot help'
      ];

      englishRequests.forEach(request => {
        mockFuzzyMatcher.detectCapabilityRequest.mockReturnValueOnce({
          isCapabilityRequest: true,
          confidence: 1.0,
          language: 'en',
          matchedTrigger: request
        });

        const result = botCapabilities.detectCapabilityRequest(request);
        expect(result.isRequest).toBe(true);
        expect(result.language).toBe('en');
        expect(result.confidence).toBe(1.0);
      });
    });

    it('should detect English capability requests with typos', () => {
      const requestsWithTypos = [
        { text: 'wat can you do', original: 'what can you do' },
        { text: 'capabilites', original: 'capabilities' },
        { text: 'featers', original: 'features' },
        { text: 'halp', original: 'help' }
      ];

      requestsWithTypos.forEach(({ text, original }) => {
        mockFuzzyMatcher.detectCapabilityRequest.mockReturnValueOnce({
          isCapabilityRequest: true,
          confidence: 0.8,
          language: 'en',
          matchedTrigger: original
        });

        const result = botCapabilities.detectCapabilityRequest(text);
        expect(result.isRequest).toBe(true);
        expect(result.language).toBe('en');
        expect(result.confidence).toBe(0.8);
        expect(result.matchedTrigger).toBe(original);
      });
    });

    it('should not detect regular messages as capability requests', () => {
      const regularMessages = [
        '–ü—Ä–∏–≤—ñ—Ç, —è–∫ —Å–ø—Ä–∞–≤–∏?',
        'Hello, how are you?',
        '–†–æ–∑–∫–∞–∂–∏ –∂–∞—Ä—Ç',
        'Tell me a joke',
        '–©–æ –Ω–æ–≤–æ–≥–æ?',
        'How was your day?',
        '–î—è–∫—É—é –∑–∞ –¥–æ–ø–æ–º–æ–≥—É'
      ];

      regularMessages.forEach(message => {
        mockFuzzyMatcher.detectCapabilityRequest.mockReturnValueOnce({
          isCapabilityRequest: false,
          confidence: 0.1,
          language: 'uk'
        });

        const result = botCapabilities.detectCapabilityRequest(message);
        expect(result.isRequest).toBe(false);
      });
    });

    it('should fallback to old method when fuzzy matching fails', () => {
      mockFuzzyMatcher.detectCapabilityRequest.mockReturnValueOnce({
        isCapabilityRequest: false,
        confidence: 0.3,
        language: 'uk'
      });

      // –¢–µ—Å—Ç fallback –ª–æ–≥—ñ–∫–∏ –∑ —Å—Ç–∞—Ä–∏–º–∏ —Ç—Ä–∏–≥–µ—Ä–∞–º–∏
      const result = botCapabilities.detectCapabilityRequest('—â–æ —Ç–∏ –º–æ–∂–µ—à');
      expect(result.isRequest).toBe(true);
      expect(result.confidence).toBe(1.0);
      expect(result.language).toBe('uk');
    });

    it('should handle fuzzy matcher errors gracefully', () => {
      mockFuzzyMatcher.detectCapabilityRequest.mockImplementationOnce(() => {
        throw new Error('Fuzzy matcher error');
      });

      // –ú–∞—î fallback –¥–æ —Å—Ç–∞—Ä–æ–≥–æ –º–µ—Ç–æ–¥—É
      const result = botCapabilities.detectCapabilityRequest('—â–æ —Ç–∏ –º–æ–∂–µ—à');
      expect(result.isRequest).toBe(true);
      expect(result.language).toBe('uk');
    });

    it('should detect partial matches in longer sentences', () => {
      const contextualRequests = [
        '–ü—Ä–∏–≤—ñ—Ç! –©–æ —Ç–∏ –º–æ–∂–µ—à —Ä–æ–±–∏—Ç–∏?',
        'Hello there, what are your capabilities?',
        '–ú–æ–∂–µ—à –ø–æ–∫–∞–∑–∞—Ç–∏ —Å–≤–æ—ó —Ñ—É–Ω–∫—Ü—ñ—ó?'
      ];

      contextualRequests.forEach(request => {
        mockFuzzyMatcher.detectCapabilityRequest.mockReturnValueOnce({
          isCapabilityRequest: true,
          confidence: 0.9,
          language: request.includes('Hello') ? 'en' : 'uk',
          matchedTrigger: request.includes('Hello') ? 'capabilities' : '—â–æ —Ç–∏ –º–æ–∂–µ—à'
        });

        const result = botCapabilities.detectCapabilityRequest(request);
        expect(result.isRequest).toBe(true);
        expect(result.confidence).toBe(0.9);
      });
    });

    it('should prioritize higher confidence matches', () => {
      mockFuzzyMatcher.detectCapabilityRequest.mockReturnValueOnce({
        isCapabilityRequest: true,
        confidence: 0.95,
        language: 'uk',
        matchedTrigger: '—â–æ —Ç–∏ –º–æ–∂–µ—à'
      });

      const result = botCapabilities.detectCapabilityRequest('—à–æ —Ç–∏ –º–æ–∂–µ—à —Ä–æ–±–∏—Ç–∏');
      expect(result.isRequest).toBe(true);
      expect(result.confidence).toBe(0.95);
      expect(result.language).toBe('uk');
    });
  });

  describe('generateCapabilitiesResponse', () => {
    it('should generate Ukrainian response by default', () => {
      const response = botCapabilities.generateCapabilitiesResponse();
      
      expect(response).toContain('–ü—Ä–∏–≤—ñ—Ç!');
      expect(response).toContain('ü§ñ **–©–æ —è –≤–º—ñ—é:**');
      expect(response).toContain('üí¨ **–°–ø—ñ–ª–∫—É–≤–∞–Ω–Ω—è**');
      expect(response).toContain('üé≠ **–†–æ–∑–≤–∞–≥–∏**');
      expect(response).toContain('üá∫üá¶');
    });

    it('should generate Ukrainian response with user name', () => {
      const response = botCapabilities.generateCapabilitiesResponse('uk', '–¢–∞—Ä–∞—Å');
      
      expect(response).toContain('–ü—Ä–∏–≤—ñ—Ç, –¢–∞—Ä–∞—Å!');
      expect(response).toContain('ü§ñ **–©–æ —è –≤–º—ñ—é:**');
    });

    it('should generate English response when requested', () => {
      const response = botCapabilities.generateCapabilitiesResponse('en');
      
      expect(response).toContain('Hello!');
      expect(response).toContain('ü§ñ **What I can do:**');
      expect(response).toContain('üí¨ **Conversations**');
      expect(response).toContain('üé≠ **Entertainment**');
      expect(response).toContain('üá∫üá¶');
    });

    it('should generate English response with user name', () => {
      const response = botCapabilities.generateCapabilitiesResponse('en', 'John');
      
      expect(response).toContain('Hello, John!');
      expect(response).toContain('ü§ñ **What I can do:**');
    });

    it('should include all capability categories', () => {
      const response = botCapabilities.generateCapabilitiesResponse('uk');
      
      expect(response).toContain('üí¨ **–°–ø—ñ–ª–∫—É–≤–∞–Ω–Ω—è**');
      expect(response).toContain('üé≠ **–†–æ–∑–≤–∞–≥–∏**');
      expect(response).toContain('üë• **–°–æ—Ü—ñ–∞–ª—å–Ω–µ**');
      expect(response).toContain('üõ°Ô∏è **–ú–æ–¥–µ—Ä–∞—Ü—ñ—è**');
      expect(response).toContain('üîß **–ö–æ—Ä–∏—Å–Ω–µ**');
    });

    it('should include examples for each capability', () => {
      const response = botCapabilities.generateCapabilitiesResponse('uk');
      
      expect(response).toContain('üì± **–Ø–∫ –≤–∏–∫–ª–∏–∫–∞—Ç–∏:**');
      expect(response).toContain('@bot + –≤–∞—à–µ –ø–∏—Ç–∞–Ω–Ω—è');
      expect(response).toContain('/meme —Ç–µ–∫—Å—Ç | —Ç–µ–∫—Å—Ç');
    });

    it('should include footer with instructions', () => {
      const ukrainianResponse = botCapabilities.generateCapabilitiesResponse('uk');
      const englishResponse = botCapabilities.generateCapabilitiesResponse('en');
      
      expect(ukrainianResponse).toContain('üí° _–ü—Ä–æ—Å—Ç–æ –ø–∏—à—ñ—Ç—å - —è —Ä–æ–∑—É–º—ñ—é!_');
      expect(englishResponse).toContain('üí° _Just start typing - I understand!_');
    });
  });

  describe('getCapabilityById', () => {
    it('should return capability by ID', () => {
      const capability = botCapabilities.getCapabilityById('ukrainian_conversation');
      
      expect(capability).toBeDefined();
      expect(capability?.id).toBe('ukrainian_conversation');
      expect(capability?.nameUk).toBe('–£–∫—Ä–∞—ó–Ω—Å—å–∫—ñ —Ä–æ–∑–º–æ–≤–∏');
      expect(capability?.category).toBe('conversation');
    });

    it('should return undefined for non-existent ID', () => {
      const capability = botCapabilities.getCapabilityById('non_existent');
      expect(capability).toBeUndefined();
    });

    it('should return all expected capabilities', () => {
      const expectedIds = [
        'ukrainian_conversation',
        'jokes_and_stories', 
        'meme_generation',
        'sentiment_reactions',
        'content_moderation',
        'user_roles',
        'atmosphere_enhancement',
        'learning_adaptation',
        'multilingual_support',
        'help_and_support'
      ];

      expectedIds.forEach(id => {
        const capability = botCapabilities.getCapabilityById(id);
        expect(capability).toBeDefined();
        expect(capability?.id).toBe(id);
      });
    });
  });

  describe('getAllCapabilities', () => {
    it('should return all capabilities', () => {
      const capabilities = botCapabilities.getAllCapabilities();
      
      expect(capabilities).toHaveLength(14);
      expect(capabilities[0]).toHaveProperty('id');
      expect(capabilities[0]).toHaveProperty('name');
      expect(capabilities[0]).toHaveProperty('nameUk');
      expect(capabilities[0]).toHaveProperty('description');
      expect(capabilities[0]).toHaveProperty('descriptionUk');
      expect(capabilities[0]).toHaveProperty('examples');
      expect(capabilities[0]).toHaveProperty('examplesUk');
      expect(capabilities[0]).toHaveProperty('category');
    });

    it('should return a copy of capabilities array', () => {
      const capabilities1 = botCapabilities.getAllCapabilities();
      const capabilities2 = botCapabilities.getAllCapabilities();
      
      expect(capabilities1).not.toBe(capabilities2); // Different references
      expect(capabilities1).toEqual(capabilities2); // Same content
    });
  });

  describe('getCapabilitiesByCategory', () => {
    it('should return capabilities by conversation category', () => {
      const conversationCapabilities = botCapabilities.getCapabilitiesByCategory('conversation');
      
      expect(conversationCapabilities).toHaveLength(1);
      expect(conversationCapabilities[0].category).toBe('conversation');
      expect(conversationCapabilities[0].id).toBe('ukrainian_conversation');
    });

    it('should return capabilities by entertainment category', () => {
      const entertainmentCapabilities = botCapabilities.getCapabilitiesByCategory('entertainment');
      
      expect(entertainmentCapabilities.length).toBeGreaterThan(0);
      entertainmentCapabilities.forEach(cap => {
        expect(cap.category).toBe('entertainment');
      });
    });

    it('should return capabilities by social category', () => {
      const socialCapabilities = botCapabilities.getCapabilitiesByCategory('social');
      
      expect(socialCapabilities.length).toBeGreaterThan(0);
      socialCapabilities.forEach(cap => {
        expect(cap.category).toBe('social');
      });
    });

    it('should return capabilities by moderation category', () => {
      const moderationCapabilities = botCapabilities.getCapabilitiesByCategory('moderation');
      
      expect(moderationCapabilities.length).toBeGreaterThan(0);
      moderationCapabilities.forEach(cap => {
        expect(cap.category).toBe('moderation');
      });
    });

    it('should return capabilities by utility category', () => {
      const utilityCapabilities = botCapabilities.getCapabilitiesByCategory('utility');
      
      expect(utilityCapabilities.length).toBeGreaterThan(0);
      utilityCapabilities.forEach(cap => {
        expect(cap.category).toBe('utility');
      });
    });

    it('should return empty array for non-existent category', () => {
      const nonExistentCapabilities = botCapabilities.getCapabilitiesByCategory('non_existent');
      expect(nonExistentCapabilities).toEqual([]);
    });

    it('should cover all categories', () => {
      const allCategories = ['conversation', 'entertainment', 'social', 'moderation', 'utility'];
      let totalCapabilities = 0;

      allCategories.forEach(category => {
        const categoryCapabilities = botCapabilities.getCapabilitiesByCategory(category);
        expect(categoryCapabilities.length).toBeGreaterThan(0);
        totalCapabilities += categoryCapabilities.length;
      });

      expect(totalCapabilities).toBe(14); // Should match total number of capabilities
    });
  });

  describe('capability data integrity', () => {
    it('should have valid capability structure for all capabilities', () => {
      const capabilities = botCapabilities.getAllCapabilities();

      capabilities.forEach(capability => {
        expect(capability.id).toBeTruthy();
        expect(capability.name).toBeTruthy();
        expect(capability.nameUk).toBeTruthy();
        expect(capability.description).toBeTruthy();
        expect(capability.descriptionUk).toBeTruthy();
        expect(Array.isArray(capability.examples)).toBe(true);
        expect(Array.isArray(capability.examplesUk)).toBe(true);
        expect(['conversation', 'entertainment', 'moderation', 'utility', 'social']).toContain(capability.category);
      });
    });

    it('should have unique capability IDs', () => {
      const capabilities = botCapabilities.getAllCapabilities();
      const ids = capabilities.map(cap => cap.id);
      const uniqueIds = [...new Set(ids)];
      
      expect(ids.length).toBe(uniqueIds.length);
    });

    it('should have both Ukrainian and English content for all capabilities', () => {
      const capabilities = botCapabilities.getAllCapabilities();

      capabilities.forEach(capability => {
        expect(capability.name).not.toBe(capability.nameUk);
        expect(capability.description).not.toBe(capability.descriptionUk);
        expect(capability.examples.length).toBeGreaterThan(0);
        expect(capability.examplesUk.length).toBeGreaterThan(0);
      });
    });
  });
}); 